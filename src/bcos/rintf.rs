use super::cintf::*;
use super::macros::*;
use alloy::primitives::Address;
use alloy::primitives::TxHash;
use alloy::providers::ParamsWithBlock;
use confy;
use libc::c_char;
use libc::c_uint;
use libc::c_void;

use serde::{Deserialize, Serialize};
use std::ffi::CStr;
use std::ffi::CString;
use std::fmt::Debug;
use std::io::Read;
use std::ops::Add;
use std::path::Path;
use std::path::PathBuf;
use std::slice;
use std::str::FromStr;
use std::sync::mpsc;

use serde_json::{json, Value as JsonValue};

#[derive(Debug, Serialize, Deserialize, Clone)]
struct SessionConfig {
    address: CString,
    /// path to private key file ([address].pem)
    private_key: CString,
    public_key: CString,
    /// path to bcos_sdk_c config file (path to config.toml)
    sdk_config: String,
}

impl Default for SessionConfig {
    fn default() -> Self {
        Self { address: Default::default(), private_key: Default::default(), public_key: Default::default(), sdk_config: "./conf/config.ini".to_owned() }
    }
}

#[derive(Debug)]
pub struct Session {
    sdk: *mut c_void,
    config: SessionConfig,
    group_id: CString,
    chain_id: CString,
    block_limit: i64,
    key_pair: *mut c_void,
}

pub trait Contract {
    /// the address of the contract object (Default::default() when deploy)
    fn address(&self) -> Address;
    /// .abi file's content (json text) generated by solc
    fn abi(&self) -> String;
    /// .bin file's context (hex text) generated by solc
    fn bin(&self) -> String;
}

impl Session {
    fn assert_sdk_success() {
        if unsafe { bcos_sdk_is_last_opr_success() == 0 } {
            unsafe {
                panic!("{}", to_string(bcos_sdk_get_last_error_msg()));
            }
        }
    }

    pub fn new(app_name: &str) -> Self {
        let config_name = "bcos_session_rust";
        let mut config: SessionConfig = confy::load(app_name, "bcos_session_rust").unwrap();

        if config.address == CString::default() {
            let keypair = unsafe {bcos_sdk_create_keypair(0)};
            config.address = unsafe{CString::from_raw(bcos_sdk_get_keypair_address(keypair))};
            config.private_key = unsafe{CStr::from_ptr(bcos_sdk_get_keypair_private_key(keypair))}.to_owned();
            config.public_key = unsafe{CStr::from_ptr(bcos_sdk_get_keypair_public_key(keypair))}.to_owned();
        }

        // 1. Construct parameters
        //   (1) create sdk object
        let bcos_sdk_config_file_cstring = CString::new(config.sdk_config.clone()).unwrap();
        let sdk = unsafe { bcos_sdk_create_by_config_file(bcos_sdk_config_file_cstring.as_ptr()) };
        Self::assert_sdk_success();
        unsafe { bcos_sdk_start(sdk); }
        Self::assert_sdk_success();
        //   (2) get common information from sdk
        // TODO: check group_id
        let group_id = CString::new("group0").unwrap();
        let chain_id = unsafe { CStr::from_ptr(bcos_sdk_get_group_chain_id(sdk, group_id.as_ptr())).to_owned() };
        Self::assert_sdk_success();
        let block_limit = unsafe { bcos_rpc_get_block_limit(sdk, group_id.as_ptr()) };
        Self::assert_sdk_success();
        //   (3) create key_pair object
        let key_pair = unsafe {
            bcos_sdk_create_keypair_by_hex_private_key(
                0,
                config.private_key.as_ptr() as *const c_char,
            )
        };
        Self::assert_sdk_success();

        confy::store(app_name, config_name, config.clone()).unwrap();

        Session {
            sdk,
            config,
            group_id,
            chain_id,
            block_limit,
            key_pair,
        }
    }

    pub fn version(&self) -> String {
        to_string(unsafe { bcos_sdk_version() })
    }

    pub fn address(&self) -> Address {
        String::from_utf8(self.config.address.as_bytes().to_owned()).unwrap().parse().unwrap()
    }

    pub fn deploy<T>(&mut self, contract: &T, params: &JsonValue) -> Result<Address, ()>
    where
        T: Contract,
    {
        // 1. Encode the constructor params by the ABI.
        let abi = CString::new(contract.abi()).unwrap();
        let bin = CString::new(contract.bin()).unwrap();
        // let params = CString::new(serde_json::to_string(params).unwrap()).unwrap();
        // let params_abi_encoded = unsafe {
        //     bcos_sdk_abi_encode_constructor(
        //         abi.as_ptr(),
        //         bin.as_ptr(),
        //         params.as_ptr(),
        //         0,
        //     )
        // };
        // Session::assert_sdk_success();

        // 3. Create the transaction object.
        let mut tx_hash: *const c_char = 0 as *const c_char;
        let mut signed_tx: *const c_char = 0 as *const c_char;
        unsafe {
            bcos_sdk_create_signed_transaction(
                self.key_pair,
                self.group_id.as_ptr(),
                self.chain_id.as_ptr(),
                EMPTY_CSTRING.as_ptr(),
                // params_abi_encoded,
                bin.as_ptr(),
                abi.as_ptr(),
                self.block_limit,
                0,
                (&mut tx_hash) as *mut *const c_char,
                (&mut signed_tx) as *mut *const c_char,
            )
        };
        Self::assert_sdk_success();

        // 4. Send the transaction object.
        let (tx, rx) = mpsc::channel::<Vec<u8>>();

        unsafe {
            bcos_rpc_send_transaction(
                self.sdk,
                self.group_id.as_ptr(),
                EMPTY_CSTRING.as_ptr(),
                signed_tx,
                0,
                session_bcos_sdk_callback,
                Box::into_raw(Box::new(tx)) as *const c_void,
            );
        }

        unsafe {
            bcos_sdk_c_free(tx_hash as *mut c_void);
            bcos_sdk_c_free(signed_tx as *mut c_void);
        }

        let output_raw = rx.recv().unwrap();

        let output: JsonValue = serde_json::from_str(&String::from_utf8(output_raw).unwrap()).unwrap();

        eprintln!("{}", output);

        let address = output.as_object().unwrap().get("result").unwrap().as_object().unwrap().get("contractAddress").unwrap().to_owned();
        let address: Address = serde_json::from_value(address).unwrap();
        Ok(address)
    }

    pub fn call<T>(&mut self, contract: &T, method: &str, params: &JsonValue) -> JsonValue
    where
        T: Contract,
    {
        // 1. Encode the method params by the ABI.
        let abi = CString::new(contract.abi()).unwrap();
        let method = CString::new(method).unwrap();
        let params = CString::new(serde_json::to_string(params).unwrap()).unwrap();
        let address = CString::new(contract.address().to_string()).unwrap();
        let params_abi_encoded = unsafe {
            bcos_sdk_abi_encode_method(
                abi.as_ptr(),
                method.as_ptr(),
                params.as_ptr(),
                0,
            )
        };
        Session::assert_sdk_success();

        // 2. Create the transaction object.
        let mut tx_hash: *const c_char = 0 as *const c_char;
        let mut signed_tx: *const c_char = 0 as *const c_char;
        unsafe {
            bcos_sdk_create_signed_transaction(
                self.key_pair,
                self.group_id.as_ptr(),
                self.chain_id.as_ptr(),
                address.as_ptr(),
                params_abi_encoded,
                abi.as_ptr(),
                self.block_limit,
                0,
                (&mut tx_hash) as *mut *const c_char,
                (&mut signed_tx) as *mut *const c_char,
            )
        };
        Self::assert_sdk_success();

        // 3. Send the transaction object.
        let (tx, rx) = mpsc::channel::<Vec<u8>>();

        unsafe {
            bcos_rpc_send_transaction(
                self.sdk,
                self.group_id.as_ptr(),
                EMPTY_CSTRING.as_ptr(),
                signed_tx,
                0,
                session_bcos_sdk_callback,
                unsafe { Box::into_raw(Box::new(tx)) as *const c_void },
            );
        }

        let output_raw = rx.recv().unwrap();

        let output: JsonValue = serde_json::from_str(&String::from_utf8(output_raw).unwrap()).unwrap();

        eprintln!("{}", &output);

        let method_output: CString = unsafe { CString::from_vec_unchecked(output.as_object().unwrap().get("result").unwrap().get("output").unwrap().as_str().unwrap().to_owned().into_bytes()) };

        unsafe {
            bcos_sdk_c_free(params_abi_encoded as *mut c_void);
            bcos_sdk_c_free(tx_hash as *mut c_void);
            bcos_sdk_c_free(signed_tx as *mut c_void);
        }

        serde_json::from_str(&to_string(unsafe { bcos_sdk_abi_decode_method_output(
            abi.as_ptr(), 
            method.as_ptr(), 
            method_output.as_ptr(), 
            0
        )})).unwrap()
    }
}

impl Drop for Session {
    fn drop(&mut self) {
        unsafe {
            bcos_sdk_destroy(self.sdk);
            bcos_sdk_destroy_keypair(self.key_pair as *mut c_void);
        }
    }
}
